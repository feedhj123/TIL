# 12/24 문제풀이
## 중간값 구하기.
- 접근 방식: sorted함수 사용하지않고 다르게 풀 수 있는 방법을 만들어보려 노력했음.

리스트 내부의 개수는 무조건 홀수로 고정된다는 조건이 있었고,(N값이 애초에 홀수임) 홀수의 경우 중간값을 찾으려면 양 옆에 무수히 위치할 최소,최댓값을 계속 지우면 된다는 결론에 도달함.

```python
T = int(input())
number_list = list(map(int ,input().split()))
for i in range(len(number_list)):
    if len(number_list) >= 3:
        #3보다 크거나 같게 설정한 이유는 리스트의 개수가 3개일때,최소 최댓값을 그상태에서 빼면 원하는 중간값이 나오기 때문임.
        number_list.remove(max(number_list))
        number_list.remove(min(number_list))
        #sorted함수를 안쓰기 때문에 인덱싱을 해서 빼오는 방법은 택할 수 없었음 때문에 값 자체를 없애서 리스트 내부의 숫자를 중간값이 계속해서 나올때까지 줄여주는 방법을 택함.
    else:
        pass
print(number_list[0]) # 리스트 내부에 3가지 숫자가 있을때 최소 최대값을 뺐으므로 최종적으로 리스트 안에는 중간값 하나만 남아있으므로 이를 인덱싱하여 출력.
```

## 달력 구하기
- 접근 방식: 처음 생각해야할 점이 3개였음 year//month//day일때, 
  
  1.month부분이 01~12의 범위를 벗어나는 경우
  
  2.day가 31일을 벗어나는 경우
  
  3.day가 각각의 달의 범위를 벗어나는 경우

8개의 입력받은 정수를 3개의 부분(year,month,day)로 나누고 이중 실제로 필요한 부분인 month와 day를 따로 받아올 방법을 생각했어야 했음.

#주석: year의 경우 어차피 정수형이었기 떄문에 어떤 숫자를 받아와도 년도의 형식을 갖출 수 있었기에 고려안했음.

month와 day는 각각의 값의 범위가 01~12,1~31로 한정되어 있었기 때문에 이를 각각 딕셔너리의 키값과 밸류로 받아 
문제를 해결하려고함.

```python
T = int(input())
DATE = {'01':31,'02':28,'03':31,'04':30,'05':31,'06':30,'07':31,'08':31,'09':30,'10':31,'11':30,'12':31}
 # 달과 날짜를 딕셔너리 형태로 생성함
for i in range(1,T+1):
    data = input()
    YEAR = data[0:4]
    MONTH = data[4:6]
    DAY = data[6:8]
    if data[4:6] not in DATE: #딕셔너리의 특성을 이용해 달부분이 1~12의 범위를 벗어나는 경우를 설정
        print(f'#{i} -1')
    elif int(data[6:8]) > DATE[data[4:6]]:
    #딕셔너리의 밸류를 받아오는 방법을 생각해서 각 달의 날짜 범위를 벗어나는 경우를 설정함. 이때 data는 문자열이므로 정수로 변환해줬음(DATE의 밸류값은 정수이기 때문에, 대소비교를 위해 정수 변환)
        print(f'#{i} -1')
    else:
        print(f'#{i} {YEAR}/{MONTH}/{DAY}')
    # 위의 2경우에 해당하지 않는다면 정상적인 달력의 날짜이므로, 그대로 출력해줌.
```