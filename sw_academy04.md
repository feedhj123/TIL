# 1244 최대상금 찾기

##  접근방식(진행중)
처음 문제를 봤을때, 단순하게 내림차순으로 정렬하고 조금만 손을 보면 쉽게 끝낼 수 있는 문제라고 생각했지만, 제약조건 및 생각지도 못하게 예외처리를 요구하는 부분들이 늘어나면서 풀이 코드를 쉽게 작성하지 못해 애먹었다.
1. 우선 가장 큰 자리수가 들어갈 부분이 첫번째 부분이기때문에, 가장 큰 수가 어디있든 우선적으로 먼저 첫째자리로 이동시키는 것을 생각했다.

2. 1.을 리스트에서 max값과 그 값의 인덱스 값을 찾아서 이를 0번째 위치와 바꿔주고 그다음에는 슬라이싱을 통해 1번째 2번째~ N번째(교환횟수)와 최댓값을 계속해서 바꿔주려는 방법을 구상했다.

3. 그러나 2.의 방법은 max로 숫자를 뽑을 경우 최댓값이 여러개 존재하는 경우 인덱스상 뒤에있는 것을 먼저 앞으로 보내는게 아니라 계속해서 맨 앞에 있는 최댓값을 앞으로 보낸다는 점을 발견했다.

4. 이를 해결하기 위해 리스트 컴프리헨션을 통해서 맥스값이 여러개인 경우, 이들의 인덱스값을 담는 리스트를 따로 만들고 리스트의 역순부터 레인지 범위를 설정하여 값을 집어넣는 방법으로 해결하려했다.

5. 그러나 while문으로 이를 설정시 while문안에 for문을 여러번 작성하면서 while문을 아예 벗어나지 못해 특정 문단을 계속 반복한다던지 아니면 특정한 상황에서 최댓값을 하나 뽑고 그 다음 최댓값을 앞으로 넘기지 못한다는 점을 발견 **(ex:78464인 경우,87644식으로 정리가 되어야하나 7이나 6이 제위치를 인덱시을통한 슬라이싱 방식으로는 제대로 제 위치를 찾지못한다.)** 하여 더이상 진행하지 못하고 중단된 상태이다.

```python 
T = int(input())
for test_case in range(1,T+1):
    reward,num_change = input().split()
    num_change = int(num_change)
    # 이후 범위 설정 및 횟수 설정을 쉽게하기 위해 int로 받아줬다.
    reward = list(reward)
    # 슬라이싱 및 인덱싱 용이하게 하기 위해, 리스트로 따로 지정해주었다.
    sort_reward = sorted(reward,reverse = True)
    left_count = 0
    while left_count < num_change:
        # 반복문의 범위를 제대로 예측하기가 어려워 우선 while문을 사용하였으나, 이후 코드 진행에 계속해서 문제가 발생하여 for문으로 수정이 가능하면 한 번 고려해봐야할듯 함.
        if len(reward) == 2 and num_change == 1:
            reward[0], reward[1] = reward[1], reward[0]
            break
            # 문자가 2개이고 교환횟수가 1회인경우 앞에 숫자가 더 크더라도 무조건적으로 교환을 한번은 해야하므로 예외로 우선 지정해주었다.
        elif reward == sort_reward:
            break
            # 77770과 같이 이미 최대값으로 정렬해 있는, 경우는 따로 건들필요 없으므로 따로 지정해두었으나 하다보니 교환횟수가 홀수냐 짝수냐에 따라 변화가 있을 수 있다는 걸 깨달았다. >> 수정이 필요하다.
        elif reward.index(max(reward)) != 0:
            # 위치상 가장 첫번째 있는것이 최대값이 아닌경우를 상정했다.
            if reward.count(max(reward)) > 1:
                MX = [i for i,mx in enumerate(reward) if mx == max(reward)]
                #리스트 내 최대값들의 위치를 담은 리스트를 생성하기 위해 리스트 컴프리헨션을 만들어 주었다. max값이 여러개일 경우, 뒤에 있는 최대값부터 앞으로 넘어가야하므로 다음과 같은 코드가 필요했다.
                [j for j in range(1,num_change+1)]
                reward[MX[-j]],reward[j-1] = reward[j-1], reward[MX[-j]]
                # 순서대로 뒤에있는 최대값부터 앞으로 밀기 위해 다음과 같이 코드를 작성했으나,>>>>>>>> 8 6 7  4 4 등과 같이 최대값 하나를 옮기고 나서 다음 최대값들을 어떻게 옮길지를 해결하지 못했으므로 이부분 수정이 필요하다.
                left_count += 1
                print(num_change)
            else:
                reward[MX[0]],reward[0] = reward[0], reward[MX[0]]
                #최대값의 개수가 복수가 아니고 1개인경우, 최대값을 그냥 바로 맨앞으로 밀어버리려 했으나,>>>>>>> 교환횟수에따라 그다음 차등의 최대값을 옮긴다던지 더 복잡한 상황을 고려하지 못했다. 코드를 확장시켜야한다.
                left_count += 1
                print(num_change)
            

    print(f'#{test_case} {"".join(reward)}')
    # 최종적으로 reward의 분절된 값들을 한데 뭉쳐서 최종상금을 나타내준다.
 ```